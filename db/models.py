# db/models.py
# INFLUE — Estrutura simplificada de persistência
# Suporte a SQLite (local) e Postgres (Neon) via DATABASE_URL.
# Ajustes cirúrgicos: migrações leves para garantir credits_temp_remaining na tabela sessions
# e backfill de valores nulos (sem afetar créditos dos usuários).

import os
from datetime import datetime

DB_URL = os.environ.get("DATABASE_URL", "sqlite:///influe.db")
_IS_PG = DB_URL.startswith("postgresql://") or DB_URL.startswith("postgres://")

# ==========================================================
# Conexão e contexto
# ==========================================================
if _IS_PG:
    # Postgres
    import psycopg
    from psycopg.rows import dict_row

    def get_connection():
        return psycopg.connect(DB_URL, row_factory=dict_row)

    from contextlib import contextmanager
    @contextmanager
    def db_cursor():
        conn = get_connection()
        try:
            cur = conn.cursor()
            yield cur
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
else:
    # SQLite
    import sqlite3
    from contextlib import contextmanager
    from pathlib import Path

    _DB_PATH = DB_URL
    if _DB_PATH.startswith("sqlite:///"):
        _DB_PATH = _DB_PATH.replace("sqlite:///", "", 1)
    elif _DB_PATH.startswith("sqlite:////"):
        _DB_PATH = _DB_PATH.replace("sqlite:////", "/", 1)

    Path(_DB_PATH).parent.mkdir(parents=True, exist_ok=True)

    def get_connection() -> sqlite3.Connection:
        # isolation_level=None => autocommit pragmático com commit/rollback manual no contextmanager
        conn = sqlite3.connect(_DB_PATH, timeout=30, isolation_level=None)
        conn.row_factory = sqlite3.Row
        return conn

    @contextmanager
    def db_cursor():
        conn = get_connection()
        try:
            cur = conn.cursor()
            yield cur
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()

# ==========================================================
# DDL base
# ==========================================================
DDL_SQLITE = [
    """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        credits_remaining INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS sessions (
        session_id TEXT PRIMARY KEY,
        ip_hash TEXT,
        ua_hash TEXT,
        credits_temp_remaining INTEGER DEFAULT 3,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS analyses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        session_id TEXT,
        type TEXT,
        meta TEXT,
        score_risk INTEGER,
        tags TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        package INTEGER,
        amount REAL,
        status TEXT,
        provider_ref TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
]

DDL_PG = [
    """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        credits_remaining INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS sessions (
        session_id TEXT PRIMARY KEY,
        ip_hash TEXT,
        ua_hash TEXT,
        credits_temp_remaining INTEGER DEFAULT 3,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS analyses (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id INTEGER,
        session_id TEXT,
        type TEXT,
        meta TEXT,
        score_risk INTEGER,
        tags TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id INTEGER,
        package INTEGER,
        amount DOUBLE PRECISION,
        status TEXT,
        provider_ref TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
]

DDL = DDL_PG if _IS_PG else DDL_SQLITE

# ==========================================================
# Migrações leves (sem perder dados)
# ==========================================================
def _column_exists_sqlite(table: str, column: str) -> bool:
    with db_cursor() as cur:
        cur.execute(f"PRAGMA table_info({table})")
        cols = [r["name"] for r in cur.fetchall()]
        return column in cols

def _column_exists_pg(table: str, column: str) -> bool:
    with db_cursor() as cur:
        cur.execute(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_name = %s AND column_name = %s
            """,
            (table, column),
        )
        return cur.fetchone() is not None

def _ensure_sessions_credits_column(default_val: int = 3):
    """
    Garante que a coluna credits_temp_remaining exista e possua default.
    Também faz backfill onde houver NULL.
    """
    if _IS_PG:
        exists = _column_exists_pg("sessions", "credits_temp_remaining")
        if not exists:
            with db_cursor() as cur:
                cur.execute("ALTER TABLE sessions ADD COLUMN credits_temp_remaining INTEGER")
                cur.execute("ALTER TABLE sessions ALTER COLUMN credits_temp_remaining SET DEFAULT %s", (default_val,))
        # Backfill de NULLs
        with db_cursor() as cur:
            cur.execute("UPDATE sessions SET credits_temp_remaining = %s WHERE credits_temp_remaining IS NULL", (default_val,))
    else:
        exists = _column_exists_sqlite("sessions", "credits_temp_remaining")
        if not exists:
            with db_cursor() as cur:
                cur.execute("ALTER TABLE sessions ADD COLUMN credits_temp_remaining INTEGER DEFAULT 3")
        # Backfill de NULLs
        with db_cursor() as cur:
            cur.execute("UPDATE sessions SET credits_temp_remaining = ? WHERE credits_temp_remaining IS NULL", (default_val,))

def init_db():
    # Cria tabelas base
    with db_cursor() as cur:
        for stmt in DDL:
            cur.execute(stmt)
    # Migração leve: garantir coluna de créditos de sessão
    _ensure_sessions_credits_column(default_val=3)

# ==========================================================
# Usuários
# ==========================================================
class User:
    def __init__(self, id, email, password_hash, credits_remaining):
        self.id = id
        self.email = email
        self.password_hash = password_hash
        self.credits_remaining = credits_remaining

def get_user_by_email(email: str):
    with db_cursor() as cur:
        cur.execute(
            "SELECT * FROM users WHERE email = %s" if _IS_PG else "SELECT * FROM users WHERE email = ?",
            (email,),
        )
        row = cur.fetchone()
        if row:
            return User(row["id"], row["email"], row["password_hash"], row["credits_remaining"])
        return None

def create_user(email: str, password_hash: str, credits: int = 0) -> int:
    with db_cursor() as cur:
        if _IS_PG:
            cur.execute(
                "INSERT INTO users (email, password_hash, credits_remaining) VALUES (%s, %s, %s) RETURNING id",
                (email, password_hash, credits),
            )
            new_id = cur.fetchone()["id"]
            return new_id
        else:
            cur.execute(
                "INSERT INTO users (email, password_hash, credits_remaining) VALUES (?, ?, ?)",
                (email, password_hash, credits),
            )
            return cur.lastrowid

def consume_user_credit_atomic(user_id: int) -> bool:
    with db_cursor() as cur:
        cur.execute(
            "SELECT credits_remaining FROM users WHERE id = %s" if _IS_PG else "SELECT credits_remaining FROM users WHERE id = ?",
            (user_id,),
        )
        row = cur.fetchone()
        if not row or (row["credits_remaining"] or 0) <= 0:
            return False
        cur.execute(
            "UPDATE users SET credits_remaining = credits_remaining - 1 WHERE id = %s" if _IS_PG else "UPDATE users SET credits_remaining = credits_remaining - 1 WHERE id = ?",
            (user_id,),
        )
        return True

# ==========================================================
# Sessões
# ==========================================================
def get_or_create_session(session_id: str, ip_hash: str, ua_hash: str, free_credits: int):
    with db_cursor() as cur:
        cur.execute(
            "SELECT session_id, credits_temp_remaining FROM sessions WHERE session_id = %s" if _IS_PG else
            "SELECT session_id, credits_temp_remaining FROM sessions WHERE session_id = ?",
            (session_id,),
        )
        row = cur.fetchone()
        if row:
            # Backfill de NULL em bases antigas
            if row.get("credits_temp_remaining") is None:
                cur.execute(
                    "UPDATE sessions SET credits_temp_remaining = %s WHERE session_id = %s" if _IS_PG else
                    "UPDATE sessions SET credits_temp_remaining = ? WHERE session_id = ?",
                    (free_credits, session_id),
                )
            return session_id

        cur.execute(
            "INSERT INTO sessions (session_id, ip_hash, ua_hash, credits_temp_remaining) VALUES (%s, %s, %s, %s)" if _IS_PG else
            "INSERT INTO sessions (session_id, ip_hash, ua_hash, credits_temp_remaining) VALUES (?, ?, ?, ?)",
            (session_id, ip_hash, ua_hash, free_credits),
        )
    return session_id

def consume_session_credit_atomic(session_id: str) -> bool:
    with db_cursor() as cur:
        cur.execute(
            "SELECT credits_temp_remaining FROM sessions WHERE session_id = %s" if _IS_PG else
            "SELECT credits_temp_remaining FROM sessions WHERE session_id = ?",
            (session_id,),
        )
        row = cur.fetchone()
        if not row or (row["credits_temp_remaining"] or 0) <= 0:
            return False
        cur.execute(
            "UPDATE sessions SET credits_temp_remaining = credits_temp_remaining - 1 WHERE session_id = %s" if _IS_PG else
            "UPDATE sessions SET credits_temp_remaining = credits_temp_remaining - 1 WHERE session_id = ?",
            (session_id,),
        )
        return True

# ==========================================================
# Análises
# ==========================================================
def record_analysis(user_id, session_id, a_type, meta, score_risk, tags):
    with db_cursor() as cur:
        cur.execute(
            (
                "INSERT INTO analyses (user_id, session_id, type, meta, score_risk, tags, created_at) "
                "VALUES (%s, %s, %s, %s, %s, %s, %s)"
            ) if _IS_PG else
            (
                "INSERT INTO analyses (user_id, session_id, type, meta, score_risk, tags, created_at) "
                "VALUES (?, ?, ?, ?, ?, ?, ?)"
            ),
            (user_id, session_id, a_type, meta, score_risk, tags, datetime.utcnow()),
        )

# ==========================================================
# Compras (Mock)
# ==========================================================
def record_purchase(user_id: int, package: int, amount: float, status: str, provider_ref: str):
    with db_cursor() as cur:
        cur.execute(
            (
                "INSERT INTO purchases (user_id, package, amount, status, provider_ref, created_at) "
                "VALUES (%s, %s, %s, %s, %s, %s)"
            ) if _IS_PG else
            (
                "INSERT INTO purchases (user_id, package, amount, status, provider_ref, created_at) "
                "VALUES (?, ?, ?, ?, ?, ?)"
            ),
            (user_id, package, amount, status, provider_ref, datetime.utcnow()),
        )

def add_credits_to_user(user_id: int, amount: int):
    with db_cursor() as cur:
        cur.execute(
            "UPDATE users SET credits_remaining = credits_remaining + %s WHERE id = %s" if _IS_PG else
            "UPDATE users SET credits_remaining = credits_remaining + ? WHERE id = ?",
            (amount, user_id),
        )
