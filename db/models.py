# db/models.py
# INFLUE — Estrutura simplificada de persistência
# Agora com suporte a SQLite (atual) e Postgres (Neon) via DATABASE_URL.

import os
from datetime import datetime

DB_URL = os.environ.get("DATABASE_URL", "sqlite:///influe.db")
_IS_PG = DB_URL.startswith("postgresql://") or DB_URL.startswith("postgres://")

# ==========================================================
# Conexão e contexto (delegando para db/__init__.py)
# ==========================================================
if _IS_PG:
    # Postgres
    import psycopg
    from psycopg.rows import dict_row

    def get_connection():
        return psycopg.connect(DB_URL, row_factory=dict_row)

    from contextlib import contextmanager
    @contextmanager
    def db_cursor():
        conn = get_connection()
        try:
            cur = conn.cursor()
            yield cur
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
else:
    # SQLite
    import sqlite3
    from contextlib import contextmanager
    from pathlib import Path

    _DB_PATH = DB_URL
    if _DB_PATH.startswith("sqlite:///"):
        _DB_PATH = _DB_PATH.replace("sqlite:///", "", 1)
    elif _DB_PATH.startswith("sqlite:////"):
        _DB_PATH = _DB_PATH.replace("sqlite:////", "/", 1)

    Path(_DB_PATH).parent.mkdir(parents=True, exist_ok=True)

    def get_connection() -> sqlite3.Connection:
        conn = sqlite3.connect(_DB_PATH, timeout=30, isolation_level=None)
        conn.row_factory = sqlite3.Row
        return conn

    @contextmanager
    def db_cursor():
        conn = get_connection()
        try:
            cur = conn.cursor()
            yield cur
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()

# ==========================================================
# Inicialização / DDL
# ==========================================================
DDL_SQLITE = [
    """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        credits_remaining INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS sessions (
        session_id TEXT PRIMARY KEY,
        ip_hash TEXT,
        ua_hash TEXT,
        credits_temp_remaining INTEGER DEFAULT 3,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS analyses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        session_id TEXT,
        type TEXT,
        meta TEXT,
        score_risk INTEGER,
        tags TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        package INTEGER,
        amount REAL,
        status TEXT,
        provider_ref TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
]

DDL_PG = [
    """
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        credits_remaining INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS sessions (
        session_id TEXT PRIMARY KEY,
        ip_hash TEXT,
        ua_hash TEXT,
        credits_temp_remaining INTEGER DEFAULT 3,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS analyses (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id INTEGER,
        session_id TEXT,
        type TEXT,
        meta TEXT,
        score_risk INTEGER,
        tags TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
    """
    CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id INTEGER,
        package INTEGER,
        amount DOUBLE PRECISION,
        status TEXT,
        provider_ref TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """,
]

DDL = DDL_PG if _IS_PG else DDL_SQLITE

def init_db():
    with db_cursor() as cur:
        for stmt in DDL:
            cur.execute(stmt)

# ==========================================================
# Usuários
# ==========================================================
class User:
    def __init__(self, id, email, password_hash, credits_remaining):
        self.id = id
        self.email = email
        self.password_hash = password_hash
        self.credits_remaining = credits_remaining

def get_user_by_email(email: str):
    with db_cursor() as cur:
        cur.execute("SELECT * FROM users WHERE email = %s" if _IS_PG else "SELECT * FROM users WHERE email = ?", (email,))
        row = cur.fetchone()
        if row:
            # psycopg dict_row -> dict; sqlite3.Row -> mapeável por nome
            return User(row["id"], row["email"], row["password_hash"], row["credits_remaining"])
        return None

def create_user(email: str, password_hash: str, credits: int = 0) -> int:
    with db_cursor() as cur:
        if _IS_PG:
            cur.execute(
                "INSERT INTO users (email, password_hash, credits_remaining) VALUES (%s, %s, %s) RETURNING id",
                (email, password_hash, credits),
            )
            new_id = cur.fetchone()["id"]
            return new_id
        else:
            cur.execute(
                "INSERT INTO users (email, password_hash, credits_remaining) VALUES (?, ?, ?)",
                (email, password_hash, credits),
            )
            return cur.lastrowid

def consume_user_credit_atomic(user_id: int) -> bool:
    with db_cursor() as cur:
        cur.execute(
            "SELECT credits_remaining FROM users WHERE id = %s" if _IS_PG else "SELECT credits_remaining FROM users WHERE id = ?",
            (user_id,),
        )
        row = cur.fetchone()
        if not row or (row["credits_remaining"] or 0) <= 0:
            return False
        cur.execute(
            "UPDATE users SET credits_remaining = credits_remaining - 1 WHERE id = %s" if _IS_PG else "UPDATE users SET credits_remaining = credits_remaining - 1 WHERE id = ?",
            (user_id,),
        )
        return True

# ==========================================================
# Sessões
# ==========================================================
def get_or_create_session(session_id: str, ip_hash: str, ua_hash: str, free_credits: int):
    with db_cursor() as cur:
        cur.execute(
            "SELECT session_id FROM sessions WHERE session_id = %s" if _IS_PG else "SELECT session_id FROM sessions WHERE session_id = ?",
            (session_id,),
        )
        row = cur.fetchone()
        if row:
            return session_id
        cur.execute(
            "INSERT INTO sessions (session_id, ip_hash, ua_hash, credits_temp_remaining) VALUES (%s, %s, %s, %s)" if _IS_PG else
            "INSERT INTO sessions (session_id, ip_hash, ua_hash, credits_temp_remaining) VALUES (?, ?, ?, ?)",
            (session_id, ip_hash, ua_hash, free_credits),
        )
    return session_id

def consume_session_credit_atomic(session_id: str) -> bool:
    with db_cursor() as cur:
        cur.execute(
            "SELECT credits_temp_remaining FROM sessions WHERE session_id = %s" if _IS_PG else "SELECT credits_temp_remaining FROM sessions WHERE session_id = ?",
            (session_id,),
        )
        row = cur.fetchone()
        if not row or (row["credits_temp_remaining"] or 0) <= 0:
            return False
        cur.execute(
            "UPDATE sessions SET credits_temp_remaining = credits_temp_remaining - 1 WHERE session_id = %s" if _IS_PG else
            "UPDATE sessions SET credits_temp_remaining = credits_temp_remaining - 1 WHERE session_id = ?",
            (session_id,),
        )
        return True

# ==========================================================
# Análises
# ==========================================================
def record_analysis(user_id, session_id, a_type, meta, score_risk, tags):
    with db_cursor() as cur:
        cur.execute(
            (
                "INSERT INTO analyses (user_id, session_id, type, meta, score_risk, tags, created_at) "
                "VALUES (%s, %s, %s, %s, %s, %s, %s)"
            ) if _IS_PG else
            (
                "INSERT INTO analyses (user_id, session_id, type, meta, score_risk, tags, created_at) "
                "VALUES (?, ?, ?, ?, ?, ?, ?)"
            ),
            (user_id, session_id, a_type, meta, score_risk, tags, datetime.utcnow()),
        )

# ==========================================================
# Compras (Mock)
# ==========================================================
def record_purchase(user_id: int, package: int, amount: float, status: str, provider_ref: str):
    with db_cursor() as cur:
        cur.execute(
            (
                "INSERT INTO purchases (user_id, package, amount, status, provider_ref, created_at) "
                "VALUES (%s, %s, %s, %s, %s, %s)"
            ) if _IS_PG else
            (
                "INSERT INTO purchases (user_id, package, amount, status, provider_ref, created_at) "
                "VALUES (?, ?, ?, ?, ?, ?)"
            ),
            (user_id, package, amount, status, provider_ref, datetime.utcnow()),
        )

def add_credits_to_user(user_id: int, amount: int):
    with db_cursor() as cur:
        cur.execute(
            "UPDATE users SET credits_remaining = credits_remaining + %s WHERE id = %s" if _IS_PG else
            "UPDATE users SET credits_remaining = credits_remaining + ? WHERE id = ?",
            (amount, user_id),
        )
